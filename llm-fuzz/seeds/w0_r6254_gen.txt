{"a": [1, 2, 3, 4, ], "b": {"c": 5, }, "d": "\x00" , "e": {}}

--- Round 2 (SAFE) ---
Input to Mutator: '{"a":[1,2,3],"b":{"c":[4,5,6]},"d":[7,8,9]}'
Mutator Code:
def mutate(data: str) -> str:
    """
    Mutates JSON strings focusing on structural integrity and common errors.
    """
    mutated_data = list(data)
    n = len(mutated_data)

    # Mutations to disrupt JSON structure
    for _ in range(random.randint(1, min(n // 5, 15) + 1)):
        idx = random.randint(0, n - 1)
        mutation_type = random.randint(0, 5)

        if mutation_type == 0 and n > 1:  # Delete a JSON structural character
            json_struct_chars = ['{', '}', '[', ']', ':', ',']
            if mutated_data[idx] in json_struct_chars:
                mutated_data.pop(idx)
                n -= 1
        elif mutation_type == 1:  # Insert a random JSON structural character
            json_struct_chars = ['{', '}', '[', ']', ':', ',']
            mutated_data.insert(idx, random.choice(json_struct_chars))
            n += 1
        elif mutation_type == 2:  # Replace a JSON structural character
            json_struct_chars = ['{', '}', '[', ']', ':', ',']
            if mutated_data[idx] in json_struct_chars:
                mutated_data[idx] = random.choice(json_struct_chars)
        elif mutation_type == 3 and n > 1:  # Swap adjacent JSON structural characters
            json_struct_chars = ['{', '}', '[', ']', ':', ',']
            swap_idx = random.randint(0, n - 2)
            if mutated_data[swap_idx] in json_struct_chars and mutated_data[swap_idx + 1] in json_struct_chars:
                mutated_data[swap_idx], mutated_data[swap_idx + 1] = mutated_data[swap_idx + 1], mutated_data[swap_idx]
        elif mutation_type == 4:  # Duplicate a JSON structural character
            json_struct_chars = ['{', '}', '[', ']', ':', ',']
            if mutated_data[idx] in json_struct_chars:
                mutated_data.insert(idx, mutated_data[idx])
                n += 1
        elif mutation_type == 5: # Insert malformed number/string
            malformed_chars = ["0.", "1.", ".1", "1e", "e1", "'hello'", '"hello', 'hello"']
            mutated_data.insert(idx, random.choice(malformed_chars))
            n += len(random.choice(malformed_chars))


    # Add some noise or unexpected characters
    noise_chars = ['\x00', '\xff', ' ', '\t', '\n', '\r', ';', '<', '>']
    for _ in range(random.randint(1, min(n // 10, 5) + 1)):
        idx = random.randint(0, n - 1)
        mutated_data.insert(idx, random.choice(noise_chars))
        n += 1

    # Ensure it remains somewhat compact
    if len(mutated_data) > 300:
        trim_amount = len(mutated_data) - 300
        mutated_data = mutated_data[random.randint(0, trim_amount) : 300 + random.randint(0, trim_amount)]
        n = len(mutated_data)

    return "".join(mutated_data)

--- Round 3 (SAFE) ---
Input to Mutator: '{"a":[1,2,3],"b":{"c":[4,5,6]},"d":[7,8,9]}'
Mutator Code:
def mutate(data: str) -> str:
    """
    Mutates JSON strings focusing on structural integrity and common errors.
    """
    mutated_data = list(data)
    n = len(mutated_data)

    # Mutations to disrupt JSON structure
    for _ in range(random.randint(1, min(n // 5, 15) + 1)):
        idx = random.randint(0, n - 1)
        mutation_type = random.randint(0, 5)

        if mutation_type == 0 and n > 1:  # Delete a JSON structural character
            json_struct_chars = ['{', '}', '[', ']', ':', ',']
            if mutated_data[idx] in json_struct_chars:
                mutated_data.pop(idx)
                n -= 1
        elif mutation_type == 1:  # Insert a random JSON structural character
            json_struct_chars = ['{', '}', '[', ']', ':', ',']
            mutated_data.insert(idx, random.choice(json_struct_chars))
            n += 1
        elif mutation_type == 2:  # Replace a JSON structural character
            json_struct_chars = ['{', '}', '[', ']', ':', ',']
            if mutated_data[idx] in json_struct_chars:
                mutated_data[idx] = random.choice(json_struct_chars)
        elif mutation_type == 3 and n > 1:  # Swap adjacent JSON structural characters
            json_struct_chars = ['{', '}', '[', ']', ':', ',']
            swap_idx = random.randint(0, n - 2)
            if mutated_data[swap_idx] in json_struct_chars and mutated_data[swap_idx + 1] in json_struct_chars:
                mutated_data[swap_idx], mutated_data[swap_idx + 1] = mutated_data[swap_idx + 1], mutated_data[swap_idx]
        elif mutation_type == 4:  # Duplicate a JSON structural character
            json_struct_chars = ['{', '}', '[', ']', ':', ',']
            if mutated_data[idx] in json_struct_chars:
                mutated_data.insert(idx, mutated_data[idx])
                n += 1
        elif mutation_type == 5: # Insert malformed number/string
            malformed_chars = ["0.", "1.", ".1", "1e", "e1", "'hello'", '"hello', 'hello"']
            mutated_data.insert(idx, random.choice(malformed_chars))
            n += len(random.choice(malformed_chars))


    # Add some noise or unexpected characters
    noise_chars = ['\x00', '\xff', ' ', '\t', '\n', '\r', ';', '<', '>']
    for _ in range(random.randint(1, min(n // 10, 5) + 1)):
        idx = random.randint(0, n - 1)
        mutated_data.insert(idx, random.choice(noise_chars))
        n += 1

    # Ensure it remains somewhat compact
    if len(mutated_data) > 300:
        trim_amount = len(mutated_data) - 300
        mutated_data = mutated_data[random.randint(0, trim_amount) : 300 + random.randint(0, trim_amount)]
        n = len(mutated_data)

    return "".join(mutated_data)

--- Round 4 (SAFE) ---
Input to Mutator: '{"data":[1,2,3,4,5],"status":"ok"}'
Mutator Code:
def mutate(data: str) -> str:
    """
    Mutates JSON strings with a focus on common parsing errors and edge cases.
    """
    mutated_data = list(data)
    n = len(mutated_data)

    # Array/Object structure manipulation
    for _ in range(random.randint(1, min(n // 8, 10) + 1)):
        idx = random.randint(0, n - 1)
        mutation_type = random.randint(0, 4)

        if mutation_type == 0 and n > 1: # Delete a bracket/brace/comma/colon
            struct_chars = ['{', '}', '[', ']', ',', ':']
            if mutated_data[idx] in struct_chars:
                mutated_data.pop(idx)
                n -= 1
        elif mutation_type == 1: # Insert a bracket/brace/comma/colon
            struct_chars = ['{', '}', '[', ']', ',', ':']
            mutated_data.insert(idx, random.choice(struct_chars))
            n += 1
        elif mutation_type == 2: # Replace a bracket/brace/comma/colon
            struct_chars = ['{', '}', '[', ']', ',', ':']
            if mutated_data[idx] in struct_chars:
                mutated_data[idx] = random.choice(struct_chars)
        elif mutation_type == 3 and n > 1: # Swap adjacent bracket/brace/comma/colon
            struct_chars = ['{', '}', '[', ']', ',', ':']
            swap_idx = random.randint(0, n - 2)
            if mutated_data[swap_idx] in struct_chars and mutated_data[swap_idx + 1] in struct_chars:
                mutated_data[swap_idx], mutated_data[swap_idx + 1] = mutated_data[swap_idx + 1], mutated_data[swap_idx]
        elif mutation_type == 4: # Duplicate a bracket/brace/comma/colon
            struct_chars = ['{', '}', '[', ']', ',', ':']
            if mutated_data[idx] in struct_chars:
                mutated_data.insert(idx, mutated_data[idx])
                n += 1

    # Value/String manipulation
    for _ in range(random.randint(1, min(n // 12, 8) + 1)):
        idx = random.randint(0, n - 1)
        mutation_type = random.randint(0, 3)

        if mutation_type == 0: # Introduce invalid control characters in strings
            if mutated_data[idx] == '"':
                insert_pos = random.randint(idx + 1, n)
                mutated_data.insert(insert_pos, random.choice(['\x00', '\x01', '\x1f']))
                n += 1
        elif mutation_type == 1: # Truncate a number or string
            if mutated_data[idx].isdigit() or mutated_data[idx] == '"':
                truncate_len = random.randint(1, 3)
                end_pos = min(idx + truncate_len, n)
                mutated_data = mutated_data[:idx] + mutated_data[end_pos:]
                n = len(mutated_data)
        elif mutation_type == 2: # Insert incomplete escape sequence
            if mutated_data[idx] == '"':
                insert_pos = random.randint(idx + 1, n)
                mutated_data.insert(insert_pos, '\\')
                mutated_data.insert(insert_pos + 1, random.choice(['u', 'x', 'z']))
                n += 2
        elif mutation_type == 3: # Replace a valid JSON value with an invalid one
            replacements = ['tru', 'fals', 'nul', '0xff', '0x00']
            replace_len = random.randint(1, 5)
            start_pos = random.randint(0, max(0, n - replace_len))
            mutated_data[start_pos:start_pos + replace_len] = list(random.choice(replacements))
            n = len(mutated_data)

    # Random byte insertion/deletion
    for _ in range(random.randint(1, min(n // 15, 5) + 1)):
        idx = random.randint(0, n - 1)
        mutation_type = random.randint(0, 1)

        if mutation_type == 0 and n > 1: # Delete byte
            mutated_data.pop(idx)
            n -= 1
        elif mutation_type == 1: # Insert random byte
            mutated_data.insert(idx, random.choice(string.printable))
            n += 1

    # Ensure not too large
    if n > 300:
        trim_len = n - 300
        start = random.randint(0, trim_len)
        mutated_data = mutated_data[start:start + 300]

    return "".join(mutated_data)

--- Round 5 (SAFE) ---
Input to Mutator: '{"numbers":[1,2,3,4,5,6],"letters":["a","b","c","d","e","f"],"bools":[true,false,true,false]}'
Mutator Code:
def mutate(data: str) -> str:
    """
    Mutates JSON strings with a focus on common parsing errors and edge cases.
    """
    mutated_data = list(data)
    n = len(mutated_data)

    # Array/Object structure manipulation
    for _ in range(random.randint(1, min(n // 8, 10) + 1)):
        idx = random.randint(0, n - 1)
        mutation_type = random.randint(0, 4)

        if mutation_type == 0 and n > 1: # Delete a bracket/brace/comma/colon
            struct_chars = ['{', '}', '[', ']', ',', ':']
            if mutated_data[idx] in struct_chars:
                mutated_data.pop(idx)
                n -= 1
        elif mutation_type == 1: # Insert a bracket/brace/comma/colon
            struct_chars = ['{', '}', '[', ']', ',', ':']
            mutated_data.insert(idx, random.choice(struct_chars))
            n += 1
        elif mutation_type == 2: # Replace a bracket/brace/comma/colon
            struct_chars = ['{', '}', '[', ']', ',', ':']
            if mutated_data[idx] in struct_chars:
                mutated_data[idx] = random.choice(struct_chars)
        elif mutation_type == 3 and n > 1: # Swap adjacent bracket/brace/comma/colon
            struct_chars = ['{', '}', '[', ']', ',', ':']
            swap_idx = random.randint(0, n - 2)
            if mutated_data[swap_idx] in struct_chars and mutated_data[swap_idx + 1] in struct_chars:
                mutated_data[swap_idx], mutated_data[swap_idx + 1] = mutated_data[swap_idx + 1], mutated_data[swap_idx]
        elif mutation_type == 4: # Duplicate a bracket/brace/comma/colon
            struct_chars = ['{', '}', '[', ']', ',', ':']
            if mutated_data[idx] in struct_chars:
                mutated_data.insert(idx, mutated_data[idx])
                n += 1

    # Value/String manipulation
    for _ in range(random.randint(1, min(n // 12, 8) + 1)):
        idx = random.randint(0, n - 1)
        mutation_type = random.randint(0, 3)

        if mutation_type == 0: # Introduce invalid control characters in strings
            if mutated_data[idx] == '"':
                insert_pos = random.randint(idx + 1, n)
                mutated_data.insert(insert_pos, random.choice(['\x00', '\x01', '\x1f']))
                n += 1
        elif mutation_type == 1: # Truncate a number or string
            if mutated_data[idx].isdigit() or mutated_data[idx] == '"':
                truncate_len = random.randint(1, 3)
                end_pos = min(idx + truncate_len, n)
                mutated_data = mutated_data[:idx] + mutated_data[end_pos:]
                n = len(mutated_data)
        elif mutation_type == 2: # Insert incomplete escape sequence
            if mutated_data[idx] == '"':
                insert_pos = random.randint(idx + 1, n)
                mutated_data.insert(insert_pos, '\\')