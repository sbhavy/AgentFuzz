# This file was automatically generated by consolidate.py
# It combines all crash-inducing mutators into a single, dispatchable corpus
# for use with AFL++'s Custom Mutator API.

# --- Core Imports (Must be available to all mutators) ---
import random 
import re
import string
import json
import time 

# --- Mutator Functions Corpus ---

# --- Source: CRASH_mut_w0_r4151.py ---
def mutate_0(data: str) -> str:
    mutated_data = list(data)
    n = len(mutated_data)

    # Randomly decide mutation operations
    operations = [
        "delete", "insert", "replace", "swap", "duplicate"
    ]
    op = random.choice(operations)

    if op == "delete" and n > 0:
        idx = random.randrange(n)
        mutated_data.pop(idx)
    elif op == "insert":
        idx = random.randrange(n + 1)
        # Insert random printable ASCII characters
        insert_char = random.choice(string.printable)
        mutated_data.insert(idx, insert_char)
    elif op == "replace" and n > 0:
        idx = random.randrange(n)
        # Replace with random printable ASCII characters
        replace_char = random.choice(string.printable)
        mutated_data[idx] = replace_char
    elif op == "swap" and n > 1:
        idx1 = random.randrange(n)
        idx2 = random.randrange(n)
        mutated_data[idx1], mutated_data[idx2] = mutated_data[idx2], mutated_data[idx1]
    elif op == "duplicate" and n > 0:
        idx = random.randrange(n)
        mutated_data.insert(idx, mutated_data[idx])

    # Apply specific JSON-like mutations with a certain probability
    if random.random() < 0.3 and n > 0: # Malformed brackets/braces
        idx = random.randrange(n)
        if mutated_data[idx] == '{':
            mutated_data[idx] = '['
        elif mutated_data[idx] == '[':
            mutated_data[idx] = '{'
        elif mutated_data[idx] == '}':
            mutated_data[idx] = ']'
        elif mutated_data[idx] == ']':
            mutated_data[idx] = '}'

    if random.random() < 0.2 and n > 0: # Unescaped quotes
        idx = random.randrange(n)
        if mutated_data[idx] == '"':
            mutated_data[idx] = "'"

    if random.random() < 0.1: # Insert control characters
        idx = random.randrange(n + 1)
        control_char = random.choice(['\x00', '\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07', '\x08', '\x09', '\x0a', '\x0b', '\x0c', '\x0d', '\x0e', '\x0f'])
        mutated_data.insert(idx, control_char)

    if random.random() < 0.1 and n > 0: # Corrupt numbers
        idx = random.randrange(n)
        if mutated_data[idx].isdigit():
            mutated_data[idx] = random.choice('abcdefg')
        elif mutated_data[idx] in ['.', 'e', '+', '-']:
            mutated_data[idx] = random.choice(string.digits)

    return "".join(mutated_data)



# --- Source: CRASH_mut_w0_r1180.py ---
def mutate_1(data: str) -> str:
    mutated_data = data
    mutations = [
        lambda d: d + "}",
        lambda d: d[:-1] if d.endswith("}") else d,
        lambda d: d.replace(" ", ""),
        lambda d: d.replace('":', '": ' if random.random() > 0.5 else '":'),
        lambda d: d.replace(",", ", ") if random.random() > 0.5 else d.replace(",", ","),
        lambda d: d.replace("[", "[ ") if random.random() > 0.5 else d.replace("[", "["),
        lambda d: d.replace("]", " ]") if random.random() > 0.5 else d.replace("]", "]"),
        lambda d: d.replace("{", "{ ") if random.random() > 0.5 else d.replace("{", "{"),
        lambda d: d.replace("}", " }") if random.random() > 0.5 else d.replace("}", "}"),
        lambda d: d.replace("null", "null ") if random.random() > 0.5 else d,
        lambda d: d.replace("true", "true ") if random.random() > 0.5 else d,
        lambda d: d.replace("false", "false ") if random.random() > 0.5 else d,
        lambda d: d.replace('"a"', '"a" ') if random.random() > 0.5 else d,
        lambda d: d.replace('1', '1 ') if random.random() > 0.5 else d,
        lambda d: d.replace('2', '2 ') if random.random() > 0.5 else d,
        lambda d: d.replace('3', '3 ') if random.random() > 0.5 else d,
        lambda d: d.replace('4', '4 ') if random.random() > 0.5 else d,
        lambda d: d.replace('"', '\\"') if random.random() > 0.5 else d,
        lambda d: d.replace("'", '"') if "'" in d else d,
        lambda d: d.replace('true', 'True') if random.random() > 0.5 else d,
        lambda d: d.replace('false', 'False') if random.random() > 0.5 else d,
        lambda d: d.replace('null', 'None') if random.random() > 0.5 else d,
        lambda d: d + random.choice([" ", "\n", "\t", "\r", "z"]),
        lambda d: d[:-1] if len(d) > 1 and random.random() > 0.5 else d,
        lambda d: d[1:] if len(d) > 1 and random.random() > 0.5 else d,
        lambda d: d.replace(", ,", ","),
        lambda d: d.replace("[,", "["),
        lambda d: d.replace(",]", "]"),
        lambda d: d.replace("{,", "{"),
        lambda d: d.replace(",}", "}"),
        lambda d: d.replace(":{", ": {"),
        lambda d: d.replace(":[", ": ["),
        lambda d: d.replace(":1", ": 1"),
        lambda d: d.replace(":'", ": '"),
        lambda d: d.replace(':"', ': "'),
        lambda d: d.replace("true,", "true, "),
        lambda d: d.replace("false,", "false, "),
        lambda d: d.replace("null,", "null, "),
        lambda d: "".join(random.sample(d, len(d))),
    ]

    num_mutations = random.randint(1, min(5, len(mutations)))
    selected_mutations = random.sample(mutations, num_mutations)

    for mutation in selected_mutations:
        mutated_data = mutation(mutated_data)

    # Add some random characters at the end
    if random.random() < 0.3:
        mutated_data += ''.join(random.choice(string.printable) for _ in range(random.randint(1, 5)))

    # Corrupt specific patterns if they exist
    if ", ," in mutated_data:
        mutated_data = mutated_data.replace(", ,", ",")
    if "[," in mutated_data:
        mutated_data = mutated_data.replace("[,", "[")
    if ",]" in mutated_data:
        mutated_data = mutated_data.replace(",]", "]")
    if "{," in mutated_data:
        mutated_data = mutated_data.replace("{,", "{")
    if ",}" in mutated_data:
        mutated_data = mutated_data.replace(",}", "}")

    return mutated_data



# --- Source: CRASH_mut_w1_r19.py ---
def mutate_2(data: str) -> str:
    """
    Aggressively mutates a JSON string to find vulnerabilities.
    """
    if not data:
        return '[]'

    mutated_data = list(data)
    length = len(mutated_data)

    # Extreme length changes
    if random.random() < 0.1:
        # Truncate
        if length > 10:
            mutated_data = mutated_data[:random.randint(1, length // 2)]
        # Extend with random characters or specific JSON patterns
        else:
            extend_len = random.randint(10, 100)
            extension = ''.join(random.choice('{}[]:,0123456789"\'\\') for _ in range(extend_len))
            mutated_data.extend(list(extension))
            length = len(mutated_data)

    # Character replacements and insertions
    num_mutations = int(length * random.uniform(0.1, 0.5))
    for _ in range(num_mutations):
        if not mutated_data:
            break
        mutation_type = random.random()
        idx = random.randint(0, len(mutated_data) - 1)

        if mutation_type < 0.3:  # Replace character
            mutated_data[idx] = random.choice('{}[]:,"\'\\0123456789 \t\n\r\b\f\v')
        elif mutation_type < 0.6:  # Insert character
            mutated_data.insert(idx, random.choice('{}[]:,"\'\\0123456789 \t\n\r\b\f\v'))
            length += 1
        elif mutation_type < 0.8:  # Delete character
            del mutated_data[idx]
            length -= 1
        else:  # Duplicate character
            mutated_data.insert(idx, mutated_data[idx])
            length += 1

    # Specific JSON-related mutations
    json_chars = ['{', '}', '[', ']', ':', ',', '"', "'"]
    special_chars = ['\\', '\'', '"', '\b', '\f', '\n', '\r', '\t', '\v', '\x00', '\xff']
    valid_escapes = ['\\', '/', '"', 'b', 'f', 'n', 'r', 't', 'u']

    mutated_str = "".join(mutated_data)
    length = len(mutated_str)

    # Corrupting string escapes
    if length > 0:
        for _ in range(random.randint(0, length // 10)):
            idx = random.randint(0, length - 1)
            if mutated_str[idx] == '\\':
                if random.random() < 0.7:
                    # Replace with invalid escape
                    mutated_str = mutated_str[:idx] + random.choice('abcdefgXYZ01') + mutated_str[idx+1:]
                else:
                    # Insert after escape
                    mutated_str = mutated_str[:idx+1] + random.choice(special_chars) + mutated_str[idx+1:]
            elif mutated_str[idx] in '"\'':
                if random.random() < 0.1:
                    mutated_str = mutated_str[:idx] + '\\' + mutated_str[idx] + mutated_str[idx+1:]
                elif random.random() < 0.2:
                    mutated_str = mutated_str[:idx] + random.choice(special_chars) + mutated_str[idx+1:]


    mutated_data = list(mutated_str)
    length = len(mutated_data)

    # Injecting control characters or invalid unicode
    if length > 0:
        for _ in range(random.randint(0, length // 20)):
            idx = random.randint(0, length - 1)
            if mutated_data[idx] == '\\' and idx + 1 < length and mutated_data[idx+1] == 'u':
                # Corrupt unicode escape
                if random.random() < 0.5:
                    mutated_data.insert(idx + 2, random.choice('XYZ'))
                else:
                    mutated_data.pop(idx + 1)
                    mutated_data.pop(idx)
                    mutated_data.insert(idx, random.choice(special_chars))

            if mutated_data[idx] == '"':
                 if random.random() < 0.05:
                     mutated_data.insert(idx + 1, '\\')
                     mutated_data.insert(idx + 2, random.choice(string.printable.replace('"', '').replace('\\', '')))
                 elif random.random() < 0.02:
                     mutated_data.insert(idx + 1, random.choice([chr(i) for i in range(32)]))


    mutated_str = "".join(mutated_data)
    length = len(mutated_str)

    # Number fuzzing
    if length > 0:
        for _ in range(random.randint(0, length // 15)):
            idx = random.randint(0, length - 1)
            if mutated_str[idx].isdigit():
                if random.random() < 0.1:
                    mutated_str = mutated_str[:idx] + random.choice('eE.+-') + mutated_str[idx:]
                elif random.random() < 0.2:
                    mutated_str = mutated_str[:idx] + random.choice(string.ascii_letters) + mutated_str[idx+1:]
                elif random.random() < 0.3:
                    mutated_str = mutated_str[:idx] + ' ' + mutated_str[idx:]

    mutated_str = "".join(mutated_data)
    length = len(mutated_str)


    # Add more extreme cases
    if random.random() < 0.05:
        mutated_str = mutated_str * random.randint(2, 5)

    if random.random() < 0.05 and length > 1:
        # Swap parts
        idx1 = random.randint(0, length // 2)
        idx2 = random.randint(length // 2, length - 1)
        part1 = mutated_str[idx1:idx1+5]
        part2 = mutated_str[idx2:idx2+5]
        mutated_str = mutated_str[:idx1] + part2 + mutated_str[idx1+5:]
        mutated_str = mutated_str[:idx2] + part1 + mutated_str[idx2+5:]


    # Ensure it's somewhat JSON-like if it became too broken
    if not mutated_str or not (mutated_str.startswith('{') or mutated_str.startswith('[')):
        if random.random() < 0.5:
            return '{}'
        else:
            return '[]'

    return mutated_str



# --- Source: CRASH_mut_w0_r4870.py ---
def mutate_3(data: str) -> str:
    s = list(data)
    n = len(s)
    for _ in range(random.randint(1, 10)):
        mutator = random.choice([
            lambda: random.choice(string.printable),
            lambda: '',
            lambda: s[random.randint(0, n - 1)] if n > 0 else '',
            lambda: random.choice(['{', '}', '[', ']', ':', ',', '"', "'", ' ', '\n', '\t']),
            lambda: random.choice(['true', 'false', 'null']),
            lambda: str(random.randint(-1000, 1000))
        ])
        mutation_type = random.randint(0, 5)

        if mutation_type == 0 and n > 0:  # Character replacement
            idx = random.randint(0, n - 1)
            s[idx] = mutator()
        elif mutation_type == 1:  # Insertion
            idx = random.randint(0, n)
            s.insert(idx, mutator())
            n += 1
        elif mutation_type == 2 and n > 0:  # Deletion
            idx = random.randint(0, n - 1)
            s.pop(idx)
            n -= 1
        elif mutation_type == 3 and n > 0:  # Swap
            idx1 = random.randint(0, n - 1)
            idx2 = random.randint(0, n - 1)
            s[idx1], s[idx2] = s[idx2], s[idx1]
        elif mutation_type == 4 and n > 0: # Duplicate
            idx = random.randint(0, n - 1)
            s.insert(idx, s[idx])
            n += 1
        elif mutation_type == 5 and n > 0: # Block deletion
            start = random.randint(0, n - 1)
            end = random.randint(start, n - 1)
            del s[start:end+1]
            n = len(s)

    return "".join(s)



# --- Source: CRASH_mut_w0_r5865.py ---
def mutate_4(data: str) -> str:
    s = list(data)
    n = len(s)
    
    # Aggressive mutations
    for _ in range(random.randint(1, n // 5 + 1)):
        op = random.randint(0, 5)
        
        if op == 0 and n > 0: # Delete a character
            i = random.randint(0, n - 1)
            s.pop(i)
            n -= 1
        elif op == 1: # Insert a random character
            i = random.randint(0, n)
            char = random.choice(string.printable)
            s.insert(i, char)
            n += 1
        elif op == 2: # Replace a character
            if n > 0:
                i = random.randint(0, n - 1)
                char = random.choice(string.printable)
                s[i] = char
        elif op == 3: # Swap characters
            if n > 1:
                i, j = random.sample(range(n), 2)
                s[i], s[j] = s[j], s[i]
        elif op == 4 and n > 0: # Duplicate a character
            i = random.randint(0, n - 1)
            s.insert(i, s[i])
            n += 1
        elif op == 5 and n > 1: # Swap adjacent characters
            i = random.randint(0, n - 2)
            s[i], s[i+1] = s[i+1], s[i]

    # Specific JSON-related mutations
    if random.random() < 0.3: # Modify numbers
        match = re.search(r'(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?', data)
        if match:
            num_str = match.group(0)
            mutated_num = num_str
            if random.random() < 0.5: # Add decimal point
                if '.' not in mutated_num:
                    insert_pos = random.randint(0, len(mutated_num))
                    mutated_num = mutated_num[:insert_pos] + '.' + mutated_num[insert_pos:]
            else: # Modify existing decimal
                if '.' in mutated_num:
                    dot_pos = mutated_num.find('.')
                    if random.random() < 0.5: # Remove decimal
                        mutated_num = mutated_num.replace('.', '')
                    else: # Shift decimal
                        parts = mutated_num.split('.')
                        if len(parts) == 2:
                            if parts[0] and parts[1]:
                                mutated_num = parts[1] + '.' + parts[0]
                            elif parts[0]:
                                mutated_num = parts[0] + '.'
                            elif parts[1]:
                                mutated_num = '.' + parts[1]
            
            if mutated_num != num_str:
                start, end = match.span()
                s = list(data[:start] + mutated_num + data[end:])

    if random.random() < 0.3: # Corrupt strings
        match = re.search(r'"([^"\\]*(\\.[^"\\]*)*)"', data)
        if match:
            start, end = match.span()
            original_str = match.group(1)
            mutated_str = list(original_str)
            
            for _ in range(random.randint(1, len(mutated_str) // 10 + 1)):
                idx = random.randint(0, len(mutated_str) - 1)
                if random.random() < 0.5:
                    mutated_str[idx] = random.choice(r'\"/') # Common escapes
                else:
                    mutated_str.pop(idx)
            
            if len(mutated_str) > 0:
                s = list(data[:start+1] + "".join(mutated_str) + data[end-1:])
            else:
                s = list(data[:start+1] + data[end-1:])


    if random.random() < 0.2: # Mismatched brackets/braces
        bracket_type = random.choice(['{}', '[]'])
        if bracket_type[0] in s:
            open_idx = s.index(bracket_type[0])
            s[open_idx] = bracket_type[1]
        elif bracket_type[1] in s:
            close_idx = s.index(bracket_type[1])
            s[close_idx] = bracket_type[0]

    if random.random() < 0.1: # Insert invalid characters
        i = random.randint(0, len(s))
        s.insert(i, random.choice('\x00\xff\xfe\xfd'))

    return "".join(s)



# --- Source: CRASH_mut_w3_r349.py ---
def mutate_5(data: str) -> str:
    """
    Mutates a JSON string to find vulnerabilities in a JSON parser.
    """
    s = list(data)
    n = len(s)
    
    # Aggressively mutate based on common JSON structures and potential edge cases
    for _ in range(random.randint(1, 10)):
        mut_type = random.randint(0, 10)

        if mut_type == 0 and n > 0:  # Delete a random character
            del s[random.randint(0, n - 1)]
            n -= 1
        elif mut_type == 1:  # Insert a random printable character
            idx = random.randint(0, n)
            s.insert(idx, random.choice(string.printable))
            n += 1
        elif mut_type == 2:  # Replace a random character
            if n > 0:
                idx = random.randint(0, n - 1)
                s[idx] = random.choice(string.printable)
        elif mut_type == 3:  # Swap two random characters
            if n > 1:
                idx1, idx2 = random.sample(range(n), 2)
                s[idx1], s[idx2] = s[idx2], s[idx1]
        elif mut_type == 4:  # Duplicate a random character
            if n > 0:
                idx = random.randint(0, n - 1)
                s.insert(idx, s[idx])
                n += 1
        elif mut_type == 5:  # Truncate the string
            if n > 0:
                s = s[:random.randint(0, n - 1)]
                n = len(s)
        elif mut_type == 6:  # Insert common JSON structural characters
            chars = ['{', '}', '[', ']', ':', ',', '"']
            idx = random.randint(0, n)
            s.insert(idx, random.choice(chars))
            n += 1
        elif mut_type == 7:  # Insert control characters
            chars = ['\x00', '\x07', '\x08', '\x0b', '\x0c', '\x0e', '\x1f']
            idx = random.randint(0, n)
            s.insert(idx, random.choice(chars))
            n += 1
        elif mut_type == 8: # Insert unicode escape sequences
            chars = ["\\u0000", "\\uffff", "\\uc9d0c", "\\u00a0"]
            idx = random.randint(0, n)
            s.insert(idx, random.choice(chars))
            n += len(random.choice(chars))
        elif mut_type == 9: # Insert incomplete escape sequences
            chars = ["\\u", "\\\\"]
            idx = random.randint(0, n)
            s.insert(idx, random.choice(chars))
            n += len(random.choice(chars))
        elif mut_type == 10: # Overwrite with a small random string
            if n > 0:
                idx = random.randint(0, n - 1)
                rand_str = ''.join(random.choice(string.printable) for _ in range(random.randint(1, 5)))
                for i, char in enumerate(rand_str):
                    if idx + i < n:
                        s[idx + i] = char
                    else:
                        s.append(char)
                        n += 1
                
    return "".join(s)



# --- Source: CRASH_mut_w0_r1866.py ---
def mutate_6(data: str) -> str:
    """
    Aggressively mutates a JSON string to potentially crash a parser.
    """
    mutated_data = list(data)
    n = len(mutated_data)

    # Randomly choose a mutation strategy
    mutation_type = random.randint(0, 9)

    if mutation_type == 0 and n > 0: # Character deletion
        idx = random.randint(0, n - 1)
        mutated_data.pop(idx)
    elif mutation_type == 1 and n > 0: # Character replacement
        idx = random.randint(0, n - 1)
        mutated_data[idx] = random.choice(string.printable)
    elif mutation_type == 2: # Character insertion
        idx = random.randint(0, n)
        mutated_data.insert(idx, random.choice(string.printable))
    elif mutation_type == 3: # String duplication
        if n > 0:
            idx = random.randint(0, n - 1)
            char_to_dup = mutated_data[idx]
            mutated_data.insert(idx, char_to_dup)
    elif mutation_type == 4: # String reversal (small chunks)
        if n > 10:
            start = random.randint(0, n - 10)
            end = min(start + random.randint(5, 10), n)
            chunk = mutated_data[start:end]
            chunk.reverse()
            mutated_data[start:end] = chunk
    elif mutation_type == 5: # Whitespace manipulation
        whitespace_chars = [' ', '\t', '\n', '\r']
        if n > 0:
            idx = random.randint(0, n - 1)
            if mutated_data[idx] in whitespace_chars:
                mutated_data.insert(idx, random.choice(whitespace_chars))
            else:
                mutated_data.insert(idx, random.choice(whitespace_chars))
    elif mutation_type == 6: # Bracket/brace manipulation
        bracket_chars = ['[', ']', '{', '}']
        if n > 0:
            idx = random.randint(0, n - 1)
            if mutated_data[idx] in bracket_chars:
                mutated_data[idx] = random.choice(bracket_chars)
    elif mutation_type == 7: # Number modification
        numeric_indices = [i for i, char in enumerate(mutated_data) if char.isdigit()]
        if numeric_indices:
            idx = random.choice(numeric_indices)
            mutated_data[idx] = random.choice(string.digits + 'eE.+-')
    elif mutation_type == 8: # String termination/escape issues
        if n > 0:
            idx = random.randint(0, n - 1)
            if mutated_data[idx] == '"':
                mutated_data.insert(idx + 1, random.choice(['\\', '\'', '\0', '\n', '\r', '"']))
            elif mutated_data[idx] == '\\':
                 mutated_data.insert(idx + 1, random.choice(['\\', '"', "'", '/', 'b', 'f', 'n', 'r', 't', 'u']))
    elif mutation_type == 9: # Overlapping or missing delimiters
        if n > 5:
            idx = random.randint(0, n - 1)
            if mutated_data[idx] in [':', ',', '[', '{', ']', '}']:
                 mutated_data.insert(idx, mutated_data[idx])


    # Ensure result is not empty and try to maintain some semblance of structure
    result = "".join(mutated_data)
    if not result:
        return "{}"
    return result



# --- Source: CRASH_mut_w0_r2053.py ---
def mutate_7(data: str) -> str:
    """
    Aggressively mutates a JSON string to find crashes in a parser.
    """
    mutated_data = data
    
    # Basic mutations: character replacement, insertion, deletion, duplication
    for _ in range(random.randint(1, 5)):
        if not mutated_data:
            return "[]" # Handle empty string case
        
        mutation_type = random.choice([
            "replace", "insert", "delete", "duplicate", "swap", "truncate", "append_noise"
        ])
        
        pos = random.randint(0, len(mutated_data))
        
        if mutation_type == "replace":
            if mutated_data:
                char_to_replace = mutated_data[pos % len(mutated_data)]
                replacement_char = random.choice([
                    "{", "}", "[", "]", ":", ",", '"', "'", 
                    "\\", "/", "t", "f", "n", "r", "u", " ", "\n", "\t",
                    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
                    ".", "-", "+", "e", "E",
                    random.choice(string.ascii_letters),
                    random.choice(string.punctuation),
                    chr(random.randint(0, 255)) # Include control characters and extended ASCII
                ])
                mutated_data = mutated_data[:pos] + replacement_char + mutated_data[pos+1:]
        elif mutation_type == "insert":
            insert_char = random.choice([
                "{", "}", "[", "]", ":", ",", '"', "'", 
                "\\", "/", "t", "f", "n", "r", "u", " ", "\n", "\t",
                "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
                ".", "-", "+", "e", "E",
                random.choice(string.ascii_letters),
                random.choice(string.punctuation),
                chr(random.randint(0, 255))
            ])
            mutated_data = mutated_data[:pos] + insert_char + mutated_data[pos:]
        elif mutation_type == "delete":
            if mutated_data:
                mutated_data = mutated_data[:pos] + mutated_data[pos+1:]
        elif mutation_type == "duplicate":
            if mutated_data:
                mutated_data = mutated_data[:pos] + mutated_data[pos] + mutated_data[pos:]
        elif mutation_type == "swap":
            if len(mutated_data) > 1:
                pos2 = random.randint(0, len(mutated_data) - 1)
                if pos != pos2:
                    data_list = list(mutated_data)
                    data_list[pos], data_list[pos2] = data_list[pos2], data_list[pos]
                    mutated_data = "".join(data_list)
        elif mutation_type == "truncate":
            mutated_data = mutated_data[:pos]
        elif mutation_type == "append_noise":
            noise_len = random.randint(1, 20)
            noise = ''.join(random.choice(string.printable) for _ in range(noise_len))
            mutated_data += noise

    # More aggressive mutations: incorrect nesting, malformed numbers, invalid escapes
    if random.random() < 0.3: # Randomly apply these more complex mutations
        mutated_data = re.sub(r'(\d+)\.(\d+)\.(\d+)\.(\d+)', r'\1.\2.\3', mutated_data) # Remove one part of IP-like numbers
        mutated_data = re.sub(r'([-+]?\d+)\.(\d+)', r'\1.\2.0', mutated_data) # Malform floats with multiple dots
        mutated_data = re.sub(r'"([^"\\]*(?:\\.[^"\\]*)*)"', lambda m: m.group(1).replace('\\', '\\\\'), mutated_data) # Escape backslashes in strings
        mutated_data = re.sub(r'"([^"\\]*(?:\\.[^"\\]*)*)"', lambda m: m.group(1).replace('"', '\\"'), mutated_data) # Escape quotes in strings
        mutated_data = re.sub(r'([{\[])', r'\1\1', mutated_data) # Duplicate opening brackets/braces
        mutated_data = re.sub(r'([}\]])', r'\1\1', mutated_data) # Duplicate closing brackets/braces
        mutated_data = re.sub(r'(\w+):', r'"\1":', mutated_data) # Unquote keys
        mutated_data = re.sub(r':(\w+)', r':"\1"', mutated_data) # Quote values
        mutated_data = re.sub(r':(true|false|null)', r': \1', mutated_data) # Add space after keywords
        mutated_data = re.sub(r'([\d.eE+-]+)', r'[\1]', mutated_data) # Wrap numbers in arrays
        mutated_data = re.sub(r'"([{}])"', r'\1', mutated_data) # Remove empty object/array strings
        mutated_data = re.sub(r'([{\[])\s*,', r'\1', mutated_data) # Remove trailing comma after opening bracket/brace
        mutated_data = re.sub(r',(\s*[}\]])', r'\1', mutated_data) # Remove leading comma before closing bracket/brace
        mutated_data = re.sub(r'\\\s*', '', mutated_data) # Remove escaped whitespace
        mutated_data = re.sub(r'([a-zA-Z0-9])([a-zA-Z0-9])', r'\1 \2', mutated_data) # Insert spaces between alphanumeric chars

    # Add some common malformed JSON patterns
    if random.random() < 0.2:
        mutated_data = "{" + mutated_data + "}" # Ensure it's wrapped in an object
        mutated_data = mutated_data.replace('{}', '{.}.')
        mutated_data = mutated_data.replace('[]', '[.].[].')
        
    # Ensure some control characters are present
    if random.random() < 0.1:
        for char_code in [0x00, 0x01, 0x07, 0x08, 0x0B, 0x0C, 0x0E, 0x1F]:
            if random.random() < 0.5:
                mutated_data += chr(char_code)

    # Truncate or repeat characters at the end for edge cases
    if len(mutated_data) > 1000:
        mutated_data = mutated_data[:random.randint(500, 1000)]
    elif len(mutated_data) < 10:
        mutated_data = mutated_data * random.randint(2, 10)

    # Final cleanup for potentially invalid JSON that might be generated
    # This is a heuristic to keep it somewhat parsable while introducing errors
    mutated_data = mutated_data.replace('\\"', '"') # Undo some escaping if it makes it invalid
    mutated_data = mutated_data.replace('"{', '{')
    mutated_data = mutated_data.replace('}"', '}')
    mutated_data = mutated_data.replace('"[', '[')
    mutated_data = mutated_data.replace(']"', ']')
    mutated_data = mutated_data.replace('":', ':')
    mutated_data = mutated_data.replace(':"', ':"')
    mutated_data = mutated_data.replace('":', '":')
    
    # Randomly corrupt characters that are unlikely to be valid JSON tokens
    chars_to_corrupt = [chr(i) for i in range(256) if chr(i) not in ' \t\n\r{}[]:, "' + string.ascii_letters + string.digits + '-.eE+']
    for _ in range(random.randint(0, 3)):
        if mutated_data:
            pos = random.randint(0, len(mutated_data) - 1)
            mutated_data = mutated_data[:pos] + random.choice(chars_to_corrupt) + mutated_data[pos+1:]

    return mutated_data

# --- Dispatch Function (Targeted by the Python Bridge) ---

def dispatch_mutate(data):
    
    # Get the list of all function names starting with 'mutate_'
    mutator_names = [name for name in globals() if name.startswith('mutate_')]
    
    if not mutator_names:
        # Fallback to a safe, non-crashing return if corpus is empty
        return data

    # Randomly select a mutator function by name
    selected_name = random.choice(mutator_names)
    
    try:
        # Get the actual function object and call it
        mutator_func = globals()[selected_name]
        return mutator_func(data)
    except Exception as e:
        # Log the failure, but ensure the fuzzer doesn't crash (critical)
        # In a C environment, this print might go to stderr or be captured by AFL++
        # print(f"[!] Dispatch Error in {selected_name}: {e}", file=sys.stderr)
        return data # Always return the original data if mutation fails

