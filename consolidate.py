import os
import re
import sys
import argparse

# Define the directory where mutators are stored (assuming it's relative to the script)
# You might need to adjust this path based on your 'config.py' DIRS['mutators']
MUTATOR_DIR = 'llm-fuzz/mutators'
OUTPUT_FILE = 'llm_corpus.py'

# Template for the final consolidated file
PYTHON_HEADER = """# This file was automatically generated by consolidate.py
# It combines all crash-inducing mutators into a single, dispatchable corpus
# for use with AFL++'s Custom Mutator API.

# --- Core Imports (Must be available to all mutators) ---
import random 
import re
import string
import json
import time 

# --- Mutator Functions Corpus ---
"""

PYTHON_DISPATCH_FOOTER = """
# --- Dispatch Function (Targeted by the Python Bridge) ---

def dispatch_mutate(data):
    
    # Get the list of all function names starting with 'mutate_'
    mutator_names = [name for name in globals() if name.startswith('mutate_')]
    
    if not mutator_names:
        # Fallback to a safe, non-crashing return if corpus is empty
        return data

    # Randomly select a mutator function by name
    selected_name = random.choice(mutator_names)
    
    try:
        # Get the actual function object and call it
        mutator_func = globals()[selected_name]
        return mutator_func(data)
    except Exception as e:
        # Log the failure, but ensure the fuzzer doesn't crash (critical)
        # In a C environment, this print might go to stderr or be captured by AFL++
        # print(f"[!] Dispatch Error in {selected_name}: {e}", file=sys.stderr)
        return data # Always return the original data if mutation fails

"""

def extract_and_rename_mutator(content, index):
    """
    Extracts the 'def mutate(...)' block and renames the function to 'mutate_INDEX'.
    """
    
    # Use the robust regex to find the function definition
    match = re.search(r"(def\s+mutate\s*\(.*?:.*?)(?=(\ndef\s+|\nclass\s+|$))", content, re.S)
    
    if not match:
        return None, "Extraction failed: 'def mutate' not found."

    code = match.group(1).strip()

    # 1. Rename the function signature
    new_func_name = f"mutate_{index}"
    renamed_code = re.sub(r"def\s+mutate\s*\(", f"def {new_func_name}(", code, 1)

    # 2. Aggressive cleanup for common LLM errors that cause SyntaxErrors
    # This removes stray trailing quotes or brackets often generated by the LLM
    # while renamed_code and renamed_code[-1] in ('"', "'", '`', ')', '}'):
    #     renamed_code = renamed_code[:-1]
    
    # 3. Add safety wrapper if needed (though LLM should handle this)
    if "return " not in renamed_code:
        renamed_code += "\n    return str(data) # Safety fallback added by consolidator"
        
    return renamed_code, None

def consolidate_mutators(mutator_dir, output_file):
    """
    Reads all .py files from mutator_dir, renames the main function, and saves
    the result to output_file with a dispatch function.
    """
    if not os.path.isdir(mutator_dir):
        print(f"Error: Mutator directory not found at '{mutator_dir}'")
        return
        
    mutator_files = [f for f in os.listdir(mutator_dir) if f.endswith(".py")]
    
    if not mutator_files:
        print("No .py files found in the mutator directory. Generating empty corpus file.")
        final_corpus = PYTHON_HEADER + PYTHON_DISPATCH_FOOTER
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(final_corpus)
        return

    mutator_count = 0
    corpus_parts = []
    
    print(f"Found {len(mutator_files)} mutator files. Starting consolidation...")
    
    for i, filename in enumerate(mutator_files):
        filepath = os.path.join(mutator_dir, filename)
        
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
            
            renamed_code, error = extract_and_rename_mutator(content, mutator_count)
            
            if renamed_code:
                # Add function to the corpus parts
                corpus_parts.append(f"\n# --- Source: {filename} ---\n{renamed_code}\n")
                mutator_count += 1
            else:
                print(f"Skipping {filename}: {error}")
                
        except UnicodeDecodeError:
            print(f"Skipping {filename}: UnicodeDecodeError (likely binary content).")
        except Exception as e:
            print(f"Skipping {filename}: General error during processing: {e}")
            
    # Assemble the final file
    final_corpus = PYTHON_HEADER
    final_corpus += "\n\n".join(corpus_parts)
    final_corpus += PYTHON_DISPATCH_FOOTER

    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(final_corpus)
        
        print(f"\nSuccessfully consolidated {mutator_count} mutators.")
        print(f"Output saved to: {output_file}")
        print("The Python bridge should target the 'dispatch_mutate' function in this file.")
        
    except Exception as e:
        print(f"Error writing output file: {e}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Consolidate LLM-generated mutator scripts.")
    parser.add_argument(
        '-i', '--input-dir', 
        default=MUTATOR_DIR, 
        help=f"Input directory containing mutator .py files (default: {MUTATOR_DIR})"
    )
    parser.add_argument(
        '-o', '--output-file', 
        default=OUTPUT_FILE, 
        help=f"Output file for the consolidated corpus (default: {OUTPUT_FILE})"
    )
    
    args = parser.parse_args()
    
    consolidate_mutators(args.input_dir, args.output_file)